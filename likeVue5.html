<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root" name="root2">
        <p>
            {{name}}-{{message}}
        </p>
        {{message}}
    </div>
</body>

</html>

<script>
    let ARRAY_METHOD = [
        'push',
        'pop',
        'shift',
        'unshift',
        'reverse',
        'sort',
        'splice',
    ];

    // 代理方法（app._data.name --> app.name）
    function proxy(app, prop, key) {
        Object.defineProperty(app, key, {
            configurable: true,
            enumerable: true,
            get() {
                return app[prop][key]
            },
            set(newVal) {
                app[prop][key] = newVal
            }
        })
    }

    function myVue(options) {
        this._data = options.data;
        this._temp = document.querySelector(options.el);
        // ???为什么要缓存parent，否则就是null?
        this._parent = this._temp.parentNode
        this.initData(); // 将 data 进行响应式转换, 进行代理

        this.mount()
    }
    myVue.prototype.mount = function () {
        // 生成虚拟DOM ???为什么不直接调用，而是要用this.render存起来
        this.render = this.createRenderFn()

        // 把生成的虚拟DOM挂载到页面上
        this.mountComponent()
    }

    myVue.prototype.createRenderFn = function () {
        // 把模板的真实DOM转换为虚拟DOM
        let ast = toVNode(this._temp)
        // 将ast中的变量用数据替换 ???这里是不是用闭包缓存_temp
        return function render() {
            // ???什么时候用函数，什么时候需要绑在原型上
            let _temp = combine(ast, this._data)
            return _temp
        }
    }

    myVue.prototype.initData = function () {
        // 修改数据的时候模板要刷新，传入this
        reactify(this._data, this)
        // 响应式化 ??? 为什么要遍历
        //   for ( let i = 0; i < keys.length; i++ ) {
        //     // 这里将 对象 this._data[ keys[ i ] ] 变成响应式的
        //     reactify( this._data, this );
        //   }
        // 代理
        for (let key in this._data) {
            proxy(this, '_data', key)
        }

    }
    // combine 和 compile 的区别 ？？？ 为什么combine里还要再new vNode，不是直接替换变量
    // 模板——》ast——》虚拟DOM
    function combine(generateNode, data) {
        let nodeType = generateNode.nodeType;
        if (nodeType === 1) {
            let tag = generateNode.tag
            let attributes = generateNode.attributes
            let children = generateNode.children
            let node = new vNode(tag, nodeType, undefined, attributes)
            // 处理子节点
            for (let i = 0; i < children.length; i++) {
                let childNode = combine(children[i], data)
                node.appendChild(childNode)
            }
            return node
        }
        else if (nodeType === 3) {
            let val = generateNode.value;
            // 正则匹配 ??为什么要取消贪婪
            let reg = /\{\{(.+)\}\}/g
            // 把匹配到的内容替换成data里的值
            let txt = val.replace(reg, function (oldVal, newVal) {
                // 回调函数的第一个参数表示匹配到的内容，第n+1个参数表示第n个分组
                let key = newVal.trim()
                // 没有嵌套的对象属性
                return getValueByPath(data, key)
                // 不 return 直接在里面替换也行？
                // childs[i].nodeValue = data[key]
            })
            let node = new vNode(undefined, nodeType, txt, undefined)
            return node;
        }

    }

    myVue.prototype.mountComponent = function () {
        // 懵逼，为什么 要写成这样
        let mount = () => {
            this.update(this.render())
        }
        mount()
        //mount.call(this)

    }

    myVue.prototype.update = function (temp) {
        // 如何做到缓存的，需不需要克隆原模板？？？
        let newTemp = toDom(temp)
        // 这里需要重新获取temp,因为它已经被替换掉了不是原来那个了
        this._parent.replaceChild(newTemp, document.querySelector('#root'))
    }
    // 对象深层查找
    function getValueByPath(obj, path) {
        let pathArr = path.split('.');
        let prop;
        // 难点
        while (prop = pathArr.shift()) {
            obj = obj[prop]
        }
        return obj
    }

    // 虚拟DOM转换为DOM
    function toDom(vNode) {
        // 判断节点类型
        if (vNode.nodeType === 1) {
            // 创建元素节点
            let node = document.createElement(vNode.tag)
            // 创建属性节点
            for (let key in vNode.attributes) {
                let value = vNode.attributes[key]
                node.setAttribute(key, value)
            }
            for (let i = 0; i < vNode.children.length; i++) {
                node.appendChild(toDom(vNode.children[i]))
            }
            return node;
        } else if (vNode.nodeType === 3) {
            let text = document.createTextNode(vNode.value);
            return text
        }
    }

    class vNode {
        constructor(tag, nodeType, value, attributes) {
            this.tag = tag;
            this.nodeType = nodeType;
            this.value = value;
            this.attributes = attributes;
            this.children = [];
        }
        appendChild(child) {
            this.children.push(child)
        }
    }

    function toVNode(dom) {
        let nodeType = dom.nodeType;
        let v_node = null
        // 元素节点需要遍历看是否有子节点
        if (nodeType === 1) {
            let tag = dom.nodeName.toLowerCase();
            let attr = dom.attributes;
            // attributes结构看不懂 类数组？
            // console.log('attr:', attributes)
            let attributes = {}
            for (let i = 0; i < attr.length; i++) {
                attributes[attr[i].nodeName] = attr[i].nodeValue
            }
            v_node = new vNode(tag, nodeType, undefined, attributes)
            for (i = 0; i < dom.childNodes.length; i++) {
                let child = toVNode(dom.childNodes[i])
                v_node.appendChild(child)
            }
        } else if (nodeType === 3) {
            let value = dom.nodeValue;
            v_node = new vNode(undefined, nodeType, value, undefined)
        }
        return v_node
    }

    let vm = new myVue({
        el: '#root',
        data: {
            name: 'storyer',
            message: '化压力为动力',
            arr: [1, 2, 3]
        }
    })


    // 响应式
    function defineReactive(vm, obj, key, value, enumerable) {
        let that = this
        Object.defineProperty(obj, key, {
            configurable: true,
            enumerable: !!enumerable,
            get() {
                return value
            },
            set(newValue) {
                // 处理直接赋值对象不能响应化的情况
                if (typeof newValue === 'object') {
                    reactify(newValue, vm)
                } else {
                    value = newValue;
                }
                // 数据改变刷新模板
                that.mountComponent()
            }
        })
    }

    // ???为什么老师的方法要复杂许多
    function reactify(obj, vm) {
        for (let key in obj) {
            let value = obj[key]
            // 如果值是数组(数组每一项是响应式但是本身不是，不能对数组重新赋值。vue2的一个bug)
            if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i++) {
                    reactify(value, vm)
                    // 数组方法拦截
                    redefineArrayMethods(value, vm)
                }
            } else if (typeof value === 'object' && value != null) {
                // 如果值是对象
                reactify(value, vm)

            } else {
                defineReactive.call(vm, vm, obj, key, value, true)
            }
        }
    }

    // 处理 push pop 等数组方法响应问题
    function redefineArrayMethods(arr, vm) {
        let array_methods = Object.create(Array.prototype)

        ARRAY_METHOD.forEach(key => {
            array_methods[key] = function () {
                // 将数据响应式化
                console.log('响应式化变量')
                for (var i = 0; i < arguments.length; i++) {
                    reactify(arguments[i], vm)
                }
                // 调用原始方法
                Array.prototype[key].apply(this, arguments)
                // Array.prototype[key](arguments) ???
            }
        })
        arr.__proto__ = array_methods
        return arr
    }

    // 发布订阅
    // 存储事件
    event = (function () {
        let eventObj = {}
        return {
            on: function (eventName, handler) {
                (eventObj[eventName] || (eventObj[eventName] = [])).push(handler)
            },
            remove: function (eventName, handler) {
                // 不传参，移除所有事件
                if (arguments.length === 0) {
                    eventObj = {}
                } else if (arguments.length === 1) {
                    // 只传了事件名，移除该事件名下所有方法
                    eventObj[eventName] = []
                } else if (arguments.length === 2) {
                    // 移除指定方法
                    let events = eventObj[eventName]
                    if (!events) return
                    // 为什么要倒着遍历
                    for (let i = 0; i < events.length; i++) {
                        if (events[i] === handler) {
                            events.splice(i, 1)
                        }
                    }
                }
            },
            emit: function (eventName) {
                let events = eventObj[eventName]
                if (!events) return
                // 挨个触发
                for (let i = 0; i < events.length; i++) {
                    // ???为什么要绑定null
                    events[i].call(null)
                }
            }
        }
    }())
</script>